import{V as I,g as k,y as f}from"./DkTpBWD-.js";import{f as D,b as G,s as S,d as B,p as F,e as K,h as M,i as Q}from"./DiVlBV5b.js";import{u as _}from"./CipUJ0Nt.js";import{u as V}from"./CG0fRItW.js";const ne=I("proxies",()=>{const i=_(),C=V(),x=f([]),m=f([]),u=f({}),d=f({}),h=f({}),g=f({}),N=f({}),O=f({}),w=f(!1),b=k("collapsedMap",{}),E=(e,t=!0)=>{const n=e.extra||{},o=Object.keys(n).reduce((s,c)=>{const r=n[c],a=r?.history?.at(-1)?.delay??i.latencyQualityMap.NOT_CONNECTED;return s.allTestUrlLatency[c]=a,s.allTestUrlLatencyHistory[c]=r?.history,s},{allTestUrlLatency:{},allTestUrlLatencyHistory:{}});if(t){const s=e.testUrl||i.urlForLatencyTest;if(!(s in o.allTestUrlLatency)){const r=e.history?.at(-1)?.delay??i.latencyQualityMap.NOT_CONNECTED;o.allTestUrlLatency[s]=r,o.allTestUrlLatencyHistory[s]=e.history}}return o},H=e=>{const t={...d.value},n={...u.value};e.forEach(o=>{const{allTestUrlLatency:s,allTestUrlLatencyHistory:c}=E(o),{udp:r,xudp:a,type:l,now:y,name:T,tfo:U,provider:P=""}=o;t[o.name]={udp:r,xudp:a,type:l,latency:y,latencyTestHistory:c,name:T,tfo:U,provider:P},(Object.values(s).some(j=>j!==i.latencyQualityMap.NOT_CONNECTED)||!n[o.name])&&(n[o.name]=s)}),d.value=t,u.value=n},v=async()=>{const[{providers:e},{proxies:t}]=await Promise.all([D(),G()]),n=Object.values(t).map(a=>{if(a.all?.length&&!a.testUrl){const{testUrl:l,timeout:y}=e?.[a.name]||{};return{...a,testUrl:l,timeout:y}}return a}),o=[...t.GLOBAL?.all??[],"GLOBAL"],s=Object.values(n).filter(a=>a.all?.length).sort((a,l)=>o.indexOf(a.name)-o.indexOf(l.name)),c=Object.values(e).filter(a=>a.name!=="default"&&a.vehicleType!=="Compatible"),r=[...n,...c.flatMap(a=>a.proxies.filter(l=>!(l.name in t)).map(l=>({...l,provider:a.name})))];x.value=s,m.value=c,H(r)},A=async(e,t)=>{if(await S(e.name,t),await v(),i.autoCloseConns){const n=C.restructRawMsgToConnection(C.latestConnectionMsg?.connections??[],[]);n.length>0&&n.forEach(({id:o,chains:s})=>{s.includes(e.name)&&B(o)})}},L=e=>{let t=d.value[e];if(!e||!t)return e;for(;t&&t.latency&&t.latency!==t.name;){const n=d.value[t.latency];if(!n)return t.name;t=n}return t?.name??e};return{proxies:x,proxyProviders:m,latencyMap:u,proxyNodeMap:d,proxyLatencyTestingMap:h,proxyGroupLatencyTestingMap:g,proxyProviderLatencyTestingMap:N,updatingMap:O,isAllProviderUpdating:w,collapsedMap:b,fetchProxies:v,selectProxyInGroup:A,getNowProxyNodeName:L,getLatencyByName:(e,t)=>{const n=t||i.urlForLatencyTest,o=u.value,s=L(e),c=o[s]?.[n],r=o[e]?.[n];if(c!=null)return c;if(r!=null)return r;const a=o[s];if(a&&Object.keys(a).length>0){const y=Object.keys(a),T=a[n]!=null?n:y[0];if(T)return a[T]}const l=o[e];if(l&&Object.keys(l).length>0){const y=Object.keys(l);if(y[0])return l[y[0]]}return i.latencyQualityMap.NOT_CONNECTED},getLatencyHistoryByName:(e,t)=>{const n=d.value[e],o=L(e),s=d.value[o],c=t||i.urlForLatencyTest,r=s?.latencyTestHistory[c]||n?.latencyTestHistory[c];if(r&&r.length)return r;const a=s?.latencyTestHistory||{},y=Object.keys(a)[0];if(y){const p=a[y];if(p&&p.length)return p}const T=n?.latencyTestHistory||{},P=Object.keys(T)[0];if(P){const p=T[P];if(p&&p.length)return p}return[]},isProxyGroup:e=>{const t=d.value[e];return t?["direct","reject","loadbalance"].includes(t.type.toLowerCase())||!!t.latency:!1},proxyLatencyTest:async(e,t,n,o)=>{const s=L(e);h.value[s]=!0;try{const c=n||i.urlForLatencyTest,r=u.value?.[s]||{},{delay:a}=await F(s,t,c,o??i.latencyTestTimeoutDuration);r[c]=a,u.value={...u.value,[s]:r}}catch{const c=n||i.urlForLatencyTest,r=u.value?.[s]||{};r[c]=i.latencyQualityMap.NOT_CONNECTED,u.value={...u.value,[s]:r}}finally{h.value[s]=!1}},proxyGroupLatencyTest:async e=>{g.value[e]=!0;try{const t=x.value.find(n=>n.name===e);await K(e,t?.testUrl||i.urlForLatencyTest,t?.timeout??i.latencyTestTimeoutDuration),await v()}finally{g.value[e]=!1}},updateProviderByProviderName:async e=>{O.value[e]=!0;try{await M(e)}catch{}await v(),O.value[e]=!1},updateAllProvider:async()=>{w.value=!0;try{await Promise.allSettled(m.value.map(e=>M(e.name))),await v()}finally{w.value=!1}},proxyProviderLatencyTest:async e=>{N.value[e]=!0;try{await Q(e),await v()}finally{N.value[e]=!1}}}});export{ne as u};
